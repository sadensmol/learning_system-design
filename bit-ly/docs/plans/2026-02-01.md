# System Design: URL Shortener

> A URL shortening service that converts long URLs into short, shareable links with analytics.

## Core Documents

- [requirements.md](../requirements.md) - Actors, constraints, scale, success criteria

## System Overview

```mermaid
flowchart TB
    subgraph Clients
        Web[Web App]
        API[API Consumers]
        Mobile[Mobile Apps]
    end

    subgraph Edge["Edge Layer"]
        CDN[CDN / Edge Cache]
        LB[Load Balancer]
    end

    subgraph Services["Application Services"]
        URLSvc[URL Service<br/>Create/Update/Delete]
        RedirectSvc[Redirect Service<br/>Lookup & Redirect]
        AnalyticsSvc[Analytics Service<br/>Async Processing]
    end

    subgraph Data["Data Layer"]
        Cache[(Redis Cache)]
        DB[(Primary Database)]
        AnalyticsDB[(Analytics Store)]
    end

    subgraph Async["Async Processing"]
        Queue[Message Queue]
    end

    Clients --> CDN
    CDN --> LB
    LB --> URLSvc
    LB --> RedirectSvc

    URLSvc --> DB
    URLSvc --> Cache

    RedirectSvc --> Cache
    Cache -.miss.-> DB
    RedirectSvc --> Queue

    Queue --> AnalyticsSvc
    AnalyticsSvc --> AnalyticsDB
```

## Service Responsibilities

| Service | Responsibility | Latency Target |
|---------|----------------|----------------|
| **URL Service** | Create, update, delete URLs; user management | < 500ms |
| **Redirect Service** | Lookup short URL â†’ long URL, redirect user | < 50ms |
| **Analytics Service** | Ingest click events, aggregate statistics | Async |

## Key Design Decisions

### 1. Separate Read/Write Paths

Redirects (reads) vastly outnumber URL creations (writes) at ~100:1 ratio. Separating these paths allows independent optimization and scaling.

### 2. Cache-First for Redirects

Most redirects are served from Redis cache. Database is only accessed on cache miss. This achieves sub-50ms latency for hot URLs.

### 3. Async Analytics

Click tracking is published to a message queue and processed asynchronously. This ensures redirects are never blocked by analytics processing.

### 4. CDN at Edge

Popular URLs are cached at CDN edge locations globally, providing lowest latency for frequently accessed links.

## Data Model

```mermaid
erDiagram
    User ||--o{ URL : creates
    URL ||--o{ Click : receives

    User {
        uuid id PK
        string email
        string api_key
        string tier
        int rate_limit
        timestamp created_at
    }

    URL {
        string short_code PK
        text long_url
        uuid user_id FK
        boolean is_custom
        timestamp expires_at
        boolean is_active
        timestamp created_at
    }

    Click {
        uuid id PK
        string short_code FK
        timestamp timestamp
        string country
        string referrer
        string device_type
    }
```

## URL State Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Active: URL Created

    Active --> Active: Redirect (normal use)
    Active --> Expired: expires_at reached
    Active --> Deleted: User deletes

    Expired --> [*]: Cleanup after cooldown
    Deleted --> Cooldown: Soft delete
    Cooldown --> [*]: After 30 days

    note right of Active
        Accepts redirects
        Tracks analytics
    end note

    note right of Cooldown
        Prevents hijacking
        URL unavailable for reuse
    end note
```

## Redirect Flow

```mermaid
sequenceDiagram
    actor User
    participant CDN
    participant Redirect as Redirect Service
    participant Cache as Redis
    participant DB as Database
    participant Queue as Message Queue

    User->>CDN: GET /abc123

    alt CDN Cache Hit
        CDN-->>User: 302 Redirect (fastest)
    else CDN Cache Miss
        CDN->>Redirect: Forward request
        Redirect->>Cache: Get url:abc123

        alt Cache Hit
            Cache-->>Redirect: long_url
        else Cache Miss
            Redirect->>DB: SELECT long_url
            DB-->>Redirect: long_url
            Redirect->>Cache: SET url:abc123
        end

        Redirect->>Queue: Click event (async)
        Redirect-->>CDN: 302 + long_url
        CDN-->>User: 302 Redirect
    end
```

## API Design

### Core Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/v1/shorten` | Create short URL |
| GET | `/{short_code}` | Redirect to long URL |
| GET | `/{short_code}+` | Preview URL info |

### Authenticated Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/urls` | List user's URLs |
| GET | `/api/v1/urls/{code}` | Get URL details |
| PATCH | `/api/v1/urls/{code}` | Update URL |
| DELETE | `/api/v1/urls/{code}` | Delete URL |
| GET | `/api/v1/urls/{code}/stats` | Get analytics |

### Response Codes

| Code | Meaning |
|------|---------|
| 302 | Redirect to long URL |
| 404 | Short URL not found |
| 410 | URL expired or deleted |
| 429 | Rate limit exceeded |

## Technical Deep Dives

For complex topics, see supporting documentation:

- [Key Generation](../key-generation.md) - Hash-based short code generation
- [Caching Strategy](../caching.md) - Multi-layer cache architecture
- [Rate Limiting](../rate-limiting.md) - Token bucket with sliding window
- [Analytics Pipeline](../analytics.md) - Async click event processing

## Scaling Strategy

### Startup Scale (10M URLs, 1K req/sec)

```mermaid
flowchart TB
    subgraph Region["Single Region"]
        LB[Load Balancer]

        subgraph Apps["Application Layer"]
            App1[App Server 1]
            App2[App Server 2]
            App3[App Server 3]
        end

        subgraph Data["Data Layer"]
            Redis[(Redis)]
            Primary[(PostgreSQL Primary)]
            Replica[(Read Replica)]
        end
    end

    CDN[CDN] --> LB
    LB --> Apps
    Apps --> Redis
    Apps --> Primary
    Apps --> Replica
```

### Enterprise Scale (1B+ URLs, 100K req/sec)

```mermaid
flowchart TB
    subgraph Global["Global Architecture"]
        CDN[Global CDN]

        subgraph US["US Region"]
            USLB[Load Balancer]
            USK8s[Kubernetes Cluster]
            USRedis[(Redis Cluster)]
            USDB[(DynamoDB)]
        end

        subgraph EU["EU Region"]
            EULB[Load Balancer]
            EUK8s[Kubernetes Cluster]
            EURedis[(Redis Cluster)]
        end

        subgraph AP["APAC Region"]
            APLB[Load Balancer]
            APK8s[Kubernetes Cluster]
            APRedis[(Redis Cluster)]
        end
    end

    CDN --> USLB
    CDN --> EULB
    CDN --> APLB

    USLB --> USK8s --> USRedis --> USDB
    EULB --> EUK8s --> EURedis --> USDB
    APLB --> APK8s --> APRedis --> USDB
```

### Scale Comparison

| Aspect | Startup | Enterprise |
|--------|---------|------------|
| Database | PostgreSQL | DynamoDB (global tables) |
| Cache | Single Redis | Redis Cluster per region |
| Compute | 3 VMs | Kubernetes with auto-scaling |
| Regions | 1 | 3+ (geo-distributed) |
| Analytics | PostgreSQL | ClickHouse cluster |

## Failure Handling

| Component | Impact | Mitigation |
|-----------|--------|------------|
| Redis down | Cache miss, higher DB load | Read from DB, auto-failover |
| Database down | Can't create new URLs | Read-only mode from cache |
| Queue full | Analytics delayed | Drop oldest, backfill later |
| CDN outage | Slower redirects | Requests hit origin |

### Degradation Levels

1. **Normal** - All features available
2. **Analytics Degraded** - Redirects work, stats delayed
3. **Write Degraded** - Redirects work, can't create URLs
4. **Cache-Only** - Only cached URLs work
5. **Complete Outage** - Static error page via CDN

## Hotspots & Open Questions

- **Key generation choice**: Hash-based chosen for simplicity; counter-based is alternative for guaranteed uniqueness
- **Database transition**: At what exact scale to migrate from PostgreSQL to DynamoDB?
- **Custom domains**: SSL certificate management for white-label domains
- **Data retention**: How long to retain raw click data vs aggregates?

## Next Steps

1. Finalize key generation approach (hash vs counter)
2. Define database migration triggers
3. Design custom domain SSL strategy
4. Set analytics retention policy
